<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>Парадигмы программирования :: Домашние задания</title><link href="hw_files/main.css" type="text/css" rel="stylesheet"><link rel="shortcut icon" href="http://www.kgeorgiy.info/favicon.ico" type="image/x-icon"><link rel="icon" href="http://www.kgeorgiy.info/favicon.ico" type="image/x-icon"><link href="hw_files/plan.html" type="text/css" rel="stylesheet"><script type="text/javascript" async="" src="hw_files/watch.js"></script><script type="text/javascript" async="" src="hw_files/ga.js"></script><script type="text/javascript">var _gaq=_gaq||[];_gaq.push(["_setAccount","UA-37693764-1"]);_gaq.push(["_setDomainName","kgeorgiy.info"]);_gaq.push(["_trackPageview"]);(function(){var a=document.createElement("script");a.type="text/javascript";a.async=!0;a.src=("https:"==document.location.protocol?"https://ssl":"http://www")+".google-analytics.com/ga.js";var b=document.getElementsByTagName("script")[0];b.parentNode.insertBefore(a,b)})();</script></head><body><table id="header"><tbody><tr><td id="breadcrumbs"><a href="http://www.kgeorgiy.info/">ГК</a> / <a href="http://www.kgeorgiy.info/courses/">Материалы курсов</a> / <a href="http://www.kgeorgiy.info/courses/paradigms/">Парадигмы программирования</a> / </td></tr><tr><td id="title">Домашние задания</td></tr></tbody></table><table id="body"><tbody><tr><td id="main"><h3 id="homework-1">Домашнее задание 1. Обработка ошибок</h3><ol><li>
            Добавьте в программу вычисляющую выражения обработку ошибок, в том числе:
            <ul><li>ошибки разбора выражений;</li><li>ошибки вычисления выражений.</li></ul></li><li>
            Для выражения <code>1000000*x*x*x*x*x/(x-1)</code> вывод программы
            должен иметь следующий вид:
            <pre>x       f
0       0
1       division by zero
2       32000000
3       121500000
4       341333333
5       overflow
6       overflow
7       overflow
8       overflow
9       overflow
10      overflow
            </pre>
            Результат <code>division by zero</code> (<code>overflow</code>) означает,
            что в процессе вычисления произошло деление на ноль (переполнение).
        </li><li>
            При выполнении задания следует обратить внимание на дизайн и обработку исключений.
        </li><li>
            Человеко-читаемые сообщения об ошибках должны выводится на консоль.
        </li><li>
            Программа не должна «вылетать» с исключениями (как стандартными, так и добавленными).
        </li></ol><p><a href="https://www.kgeorgiy.info/git/geo/paradigms-2020">Тесты к домашним заданиям</a></p><h3 id="homework-2">Домашнее задание 2. Бинарный поиск</h3><ol><li>
            Реализуйте итеративный и рекурсивный варианты бинарного поиска в массиве.
        </li><li>
            На вход подается целое число <code>x</code> и массив целых чисел <code>a</code>,
            отсортированный по невозрастанию.
            Требуется найти минимальное значение индекса <code>i</code>,
            при котором <code>a[i] &lt;= x</code>.
        </li><li>
            Для функций бинарного поиска и вспомогательных функций должны быть указаны,
            пред- и постусловия. Для реализаций методов должны быть приведены
            доказательства соблюдения контрактов в терминах троек Хоара.
        </li><li>
            Интерфейс программы.
            <ul><li>Имя основного класса — <code>BinarySearch</code>.</li><li>Первый аргумент командной строки — число <code>x</code>.</li><li>Последующие аргументы командной строки — элементы массива <code>a</code>.</li></ul></li><li>
            Пример запуска: <code>java BinarySearch 3 5 4 3 2 1</code>.
            Ожидаемый результат: <code>2</code>.
        </li></ol><h3 id="homework-3">Домашнее задание 3. Очередь на массиве</h3><ol><li>
            Найдите инвариант структуры данных «<a href="http://ru.wikipedia.org/wiki/%D0%9E%D1%87%D0%B5%D1%80%D0%B5%D0%B4%D1%8C_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)">очередь</a>».
            Определите функции, которые необходимы для реализации очереди.
            Найдите их пред- и постусловия, при условии что очередь не содержит <code>null</code>.
        </li><li>
            Реализуйте классы, представляющие циклическую очередь с применением массива.
            <ul><li>
                    Класс <code>ArrayQueueModule</code> должен реализовывать один экземпляр
                    очереди с использованием переменных класса.
                </li><li>
                    Класс <code>ArrayQueueADT</code> должен реализовывать очередь в виде
                    абстрактного типа данных (с явной передачей ссылки на экземпляр очереди).
                </li><li>
                    Класс <code>ArrayQueue</code> должен реализовывать очередь в виде
                    класса (с неявной передачей ссылки на экземпляр очереди).
                </li><li>
                    Должны быть реализованы следующие функции (процедуры) / методы:
                    <ul><li><code>enqueue</code> – добавить элемент в очередь;</li><li><code>element</code> – первый элемент в очереди;</li><li><code>dequeue</code> – удалить и вернуть первый элемент в очереди;</li><li><code>size</code> – текущий размер очереди;</li><li><code>isEmpty</code> – является ли очередь пустой;</li><li><code>clear</code> – удалить все элементы из очереди.</li></ul></li><li>
                    Инвариант, пред- и постусловия записываются в исходном коде в виде
                    комментариев.
                </li><li>
                    Обратите внимание на инкапсуляцию данных и кода во всех трех реализациях.
                </li></ul></li><li>
            Напишите тесты к реализованным классам.
        </li></ol><h3 id="homework-4">Домашнее задание 4. Очереди</h3><ol><li>
            Определите интерфейс очереди <code>Queue</code> и опишите его контракт.
        </li><li>
            Реализуйте класс <code>LinkedQueue</code> — очередь на связном списке.
        </li><li>
            Выделите общие части классов <code>LinkedQueue</code>
            и <code>ArrayQueue</code> в базовый класс <code>AbstractQueue</code>.
        </li></ol><h3 id="homework-5">Домашнее задание 5. Вычисление в различных типах</h3><ol><li>
            Добавьте в программу разбирающую и вычисляющую выражения поддержку различных типов.
            <ul><li>
                    Первым аргументом командной строки программа должна принимать указание
                    на тип, в котором будут производится вычисления:
                    <table><tbody><tr><th>Опция</th><th>Тип</th></tr><tr><td><code>-i</code></td><td><code>int</code></td></tr><tr><td><code>-d</code></td><td><code>double</code></td></tr><tr><td><code>-bi</code></td><td><code><a href="http://docs.oracle.com/javase/8/docs/api/java/math/BigInteger.html">BigInteger</a></code></td></tr></tbody></table></li><li>
                    Вторым аргументом командной строки программа должна принимать
                    выражение для вычисления.
                </li><li>
                    Реализация не должна содержать
                    <a href="http://docs.oracle.com/javase/specs/jls/se8/html/jls-5.html#jls-5.1.9">непроверяемых преобразований типов</a>.
                </li><li>
                    Реализация не должна использовать аннотацию
                    <code><a href="http://docs.oracle.com/javase/specs/jls/se8/html/jls-9.html#jls-9.6.4.5">@SuppressWarnings</a></code>.
                </li></ul></li><li>
            При выполнении задания следует обратить внимание на легкость добавления новых типов и операциий.
        </li></ol><h3 id="homework-6">Домашнее задание 6. Функциональные выражения на JavaScript</h3><ol><li>
            Разработайте функции <code>cnst</code>, <code>variable</code>,
            <code>add</code>, <code>subtract</code>, <code>multiply</code>,
            <code>divide</code>, <code>negate</code>
            для вычисления выражений с одной переменной.
        </li><li>
            Функции должны позволять производить вычисления вида:
            <pre>let expr = subtract(
    multiply(
        cnst(2),
        variable("x")
    ),
    cnst(3)
);
println(expr(5));
            </pre>
            При вычислении такого выражения вместо каждой переменной подставляется значение,
            переданное в качестве параметра функции <code>expr</code> (на данном этапе
            имена переменных игнорируются). Таким образом, результатом вычисления
            приведенного примера должно стать число 7.
        </li><li>
            Тестовая программа должна вычислять выражение
            <code>x<sup>2</sup>−2x+1</code>, для <code>x</code> от 0 до 10.
        </li><li><b>Сложный вариант.</b> Требуется написать функцию
            <code>parse</code>, осуществляющую разбор выражений,
            записанных в
            <a href="http://ru.wikipedia.org/wiki/%D0%9E%D0%B1%D1%80%D0%B0%D1%82%D0%BD%D0%B0%D1%8F_%D0%BF%D0%BE%D0%BB%D1%8C%D1%81%D0%BA%D0%B0%D1%8F_%D0%B7%D0%B0%D0%BF%D0%B8%D1%81%D1%8C">обратной польской записи</a>.
            Например, результатом
            <pre>parse("x x 2 - * x * 1 +")(5)</pre>
            должно быть число <code>76</code>.
        </li><li>
            При выполнение задания следует обратить внимание на:
            <ul><li>
                    Применение функций высшего порядка.
                </li><li>
                    Выделение общего кода для бинарных операций.
                </li></ul></li></ol><h3 id="homework-7">Домашнее задание 7. Объектные выражения на JavaScript</h3><ol><li>
            Разработайте классы <code>Const</code>, <code>Variable</code>,
            <code>Add</code>, <code>Subtract</code>, <code>Multiply</code>,
            <code>Divide</code>, <code>Negate</code>
            для представления выражений с одной переменной.
            <ol><li>
                    Пример описания выражения <code>2x-3</code>:
                    <pre>let expr = new Subtract(
    new Multiply(
        new Const(2),
        new Variable("x")
    ),
    new Const(3)
);
                    </pre></li><li>
                    Метод <code>evaluate(x)</code> должен производить вычисления вида:
                    При вычислении такого выражения вместо каждой переменной подставляется значение <code>x</code>,
                    переданное в качестве параметра функции <code>evaluate</code> (на данном этапе
                    имена переменных игнорируются). Таким образом, результатом вычисления
                    приведенного примера должно стать число 7.
                </li><li>
                    Метод <code>toString()</code> должен выдавать
                    запись выражения в
                    <a href="http://ru.wikipedia.org/wiki/%D0%9E%D0%B1%D1%80%D0%B0%D1%82%D0%BD%D0%B0%D1%8F_%D0%BF%D0%BE%D0%BB%D1%8C%D1%81%D0%BA%D0%B0%D1%8F_%D0%B7%D0%B0%D0%BF%D0%B8%D1%81%D1%8C">обратной польской записи</a>.
                    Например, <code>expr.toString()</code> должен выдавать
                    <code>2 x * 3 -</code>.
                </li></ol></li><li><b>Сложный вариант.</b><div>
            Метод <code>diff("x")</code> должен возвращать выражение,
            представляющее производную исходного выражения
            по переменной <code>x</code>.
            Например, <code>expr.diff("x")</code> должен возвращать
            выражение, эквивалентное <code>new Const(2)</code>
            (выражения
                <code>new Subtract(new Const(2), new Const(0))</code> и
                <pre>new Subtract(
    new Add(
        new Multiply(new Const(0), new Variable("x")),
        new Multiply(new Const(2), new Const(1))
    )
    new Const(0)
)
                 </pre>
                 так же будут считаться правильным ответом).
            </div><p>
                Функция <code>parse</code> должна выдавать разобранное
                объектное выражение.
            </p></li><li><b>Бонусный вариант.</b>
            Требуется написать
            метод <code>simplify()</code>, производящий вычисления
            константных выражений. Например,
            <pre>parse("x x 2 - * 1 *").diff("x").simplify().toString()</pre>
            должно возвращать «<code>x x 2 - +</code>».
        </li><li>
            При выполнение задания следует обратить внимание на:
            <ul><li>
                    Применение инкапсуляции.
                </li><li>
                    Выделение общего кода для операций.
                </li></ul></li></ol><h3 id="homework-8">Домашнее задание 8. Обработка ошибок на JavaScript</h3><ol><li>
            Добавьте в предыдущее домашнее задание функцию
            <code>parsePrefix(string)</code>, разбирающую выражения,
            задаваемые записью вида <code>(- (* 2 x) 3)</code>.
            Если разбираемое выражение некорректно, метод
            <code>parsePrefix</code> должен бросать
            человеко-читаемое сообщение об ошибке.
        </li><li>
            Добавьте в предыдущее домашнее задание метод
            <code>prefix()</code>, выдающий выражение в формате,
            ожидаемом функцией <code>parsePrefix</code>.
        </li><li>
            При выполнение задания следует обратить внимание на:
            <ul><li>
                    Применение инкапсуляции.
                </li><li>
                    Выделение общего кода для бинарных операций.
                </li><li>
                    Обработку ошибок.
                </li><li>
                    Минимизацию необходимой памяти.
                </li></ul></li></ol><h3 id="homework-9">Домашнее задание 9. Линейная алгебра на Clojure</h3><ol><li>
            Разработайте функции для работы с объектами линейной алгебры,
            которые представляются следующим образом:
            <ul><li>скаляры – числа</li><li>векторы – векторы чисел;</li><li>матрицы – векторы векторов чисел.</li></ul></li><li>
            Функции над векторами:
            <ul><li><code>v+</code>/<code>v-</code>/<code>v*</code>
                    – покоординатное сложение/вычитание/умножение;
                </li><li><code>scalar</code>/<code>vect</code>
                    – скалярное/векторное произведение;
                </li><li><code>v*s</code>
                    – умножение на скаляр.
                </li></ul></li><li>
            Функции над матрицами:
            <ul><li><code>m+</code>/<code>m-</code>/<code>m*</code>
                    – поэлементное сложение/вычитание/умножение;
                </li><li><code>m*s</code> – умножение на скаляр;
                </li><li><code>m*v</code> – умножение на вектор;
                </li><li><code>m*m</code> – матричное умножение;
                </li><li><code>transpose</code> – траспонирование;
                </li></ul></li><li><b>Сложный вариант.</b><ol><li>
                    Ко всем функциям должны быть указаны контракты.
                    Например, нельзя складывать вектора разной длины.
                </li><li>
                    Все функции должны поддерживать произвольное число аргументов.
                    Например
                    <code>(v+ [1 2] [3 4] [5 6])</code> должно быть равно
                    <code>[9 12]</code>.
                </li></ol></li><li>
            При выполнение задания следует обратить внимание на:
            <ul><li>
                    Применение функций высшего порядка.
                </li><li>
                    Выделение общего кода для операций.
                </li></ul></li></ol><h3 id="homework-10">Домашнее задание 10. Функциональные выражения на Clojure</h3><ol><li>
            Разработайте функции
            <code>constant</code>,
            <code>variable</code>,
            <code>add</code>,
            <code>subtract</code>,
            <code>multiply</code> и
            <code>divide</code>
            для представления арифметических выражений.
            <ol><li>
                    Пример описания выражения <code>2x-3</code>:
                    <pre>(def expr
  (subtract
    (multiply
      (constant 2)
      (variable "x"))
    (constant 3)))
                    </pre></li><li>
                    Выражение должно быть функцией, возвращающей
                    значение выражение при подстановке элементов,
                    заданных отображением.
                    Например, <code>(expr {"x" 2})</code> должно быть равно 1.
                </li></ol></li><li>
            Разработайте разборщик выражений, читающий
            выражения в стандартной для Clojure форме.
            Например, <pre>(parseFunction "(- (* 2 x) 3)")</pre>
            должно быть эквивалентно <code>expr</code>.
        </li><li><b>Сложный вариант.</b>
            Функции <code>add</code>, <code>subtract</code>,
            <code>multiply</code> и <code>divide</code>
            должны принимать произвольное число аргументов.
            Разборщик так же должен допускать произвольное число
            аргументов для <code>+</code>, <code>-</code>, <code>*</code>.
        </li><li>
            При выполнение задания следует обратить внимание на:
            <ul><li>
                    Выделение общего кода для операций.
                </li></ul></li></ol><h3 id="homework-11">Домашнее задание 11. Объектные выражения на Clojure</h3><ol><li>
            Разработайте конструкторы
            <code>Constant</code>,
            <code>Variable</code>,
            <code>Add</code>,
            <code>Subtract</code>,
            <code>Multiply</code> и
            <code>Divide</code>
            для представления выражений с одной переменной.
            <ol><li>
                    Пример описания выражения <code>2x-3</code>:
                    <pre>(def expr
  (Subtract
    (Multiply
      (Constant 2)
      (Variable "x"))
    (Const 3)))
                    </pre></li><li>
                    Функция <code>(evaluate expression vars)</code>
                    должна производить вычисление выражения
                    <code>expression</code> для значений
                    переменных, заданных отображением <code>vars</code>.
                    Например, <code>(evaluate expr {"x" 2})</code>
                    должно быть равно 1.
                </li><li>
                    Функция <code>(toString expression)</code>
                    должна выдавать запись выражения в
                    стандартной для Clojure форме.
                </li><li>
                    Функция <code>(parseObject "expression")</code>
                    должна разбирать выражения, записанные
                    в стандартной для Clojure форме.
                    Например, <pre>(parseObject "(- (* 2 x) 3)")</pre>
                    должно быть эквивалентно <code>expr</code>.
                </li><li>
                    Функция <code>(diff expression "variable")</code>
                    должена возвращать выражение,
                    представляющее производную исходного выражения
                    по заданой пермененной.
                    Например, <code>(diff expression "x")</code>
                    должен возвращать выражение, эквивалентное
                    <code>(Constant 2)</code>, при этом
                    выражения
                    <code>(Subtract (Const 2) (Const 0))</code> и
                    <pre>(Subtract
  (Add
    (Multiply (Const 0) (Variable "x"))
    (Multiply (Const 2) (Const 1)))
  (Const 0))
                    </pre>
                    так же будут считаться правильным ответом.
                </li></ol></li><li><b>Сложный вариант.</b>
            Констуркторы <code>Add</code>, <code>Subtract</code>,
            <code>Multiply</code> и <code>Divide</code>
            должны принимать произвольное число аргументов.
            Разборщик так же должен допускать произвольное число
            аргументов для <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>.
        </li><li>
            При выполнение задания можно использовать
            любой способ преставления объектов.
        </li></ol><h3 id="homework-12">Домашнее задание 12. Комбинаторные парсеры</h3><ol><li><b>Простой вариант.</b>
            Реализуйте функцию <code>(parseObjectSuffix "expression")</code>,
            разбирающую выражения, записанные в суффиксной форме,
            и функцию <code>toStringSuffix</code>,
            возвращающую строковое представление выражения в этой форме.
            Например, <pre>(toStringSuffix (parseObjectSuffix "( ( 2 x * ) 3 - )"))</pre>
            должно возвращать <code>((2 x *) 3 -)</code>.
        </li><li><b>Сложный вариант.</b>
            Реализуйте функцию <code>(parseObjectInfix "expression")</code>,
            разбирающую выражения, записанные в инфиксной форме,
            и функцию <code>toStringInfix</code>,
            возвращающую строковое представление выражения в этой форме.
            Например, <pre>(toStringInfix (parseObjectInfix "2 * x - 3"))</pre>
            должно возвращать <code>((2 * x) - 3)</code>.
        </li><li><b>Бонусный вариант.</b>
            Добавьте в библиотеку комбинаторов возможность обработки ошибок
            и продемонстрируйте ее использование в вашем парсере.
        </li><li>
            Функции разбора должны базироваться на библиотеке
            комбинаторов, разработанной на лекции.
        </li></ol><h3 id="homework-13">Домашнее задание 13. Простые числа на Prolog</h3><ol><li><p>
                Разработайте правила:
                </p><ul><li><code>prime(N)</code>,
                        проверяющее, что <code>N</code> – простое число.
                    </li><li><code>composite(N)</code>,
                        проверяющее, что <code>N</code> – составное число.
                    </li><li><code>prime_divisors(N, Divisors)</code>,
                        проверяющее, что список <code>Divisors</code>
                        содержит все простые делители числа <code>N</code>,
                        упорядоченные по возрастанию.
                        Если <code>N</code> делится на простое число <code>P</code>
                        несколько раз, то <code>Divisors</code> должен содержать
                        соответствующее число копий <code>P</code>.
                    </li></ul><p></p></li><li><p>Варианты</p><ul><li>Простой: <code>N</code> ≤ 1000.</li><li>Сложный: <code>N</code> ≤ 10<sup>5</sup>.</li><li>Бонусный: <code>N</code> ≤ 10<sup>7</sup>.</li></ul></li><li>
            Вы можете рассчитывать, на то, что до первого запроса будет
            выполнено правило <code>init(MAX_N)</code>.
        </li></ol><h3 id="homework-14">Домашнее задание 14. Деревья поиска на Prolog</h3><ol><li>
            Реализуйте ассоциативный массив (map) на основе деревьев поиска.
            Для решения можно реализовать любое дерево поиска логарифмической высоты.
        </li><li><p><b>Простой вариант.</b>
                Разработайте правила:
            </p><ul><li><code>map_build(ListMap, TreeMap)</code>,
                    строящее дерево из упорядоченного списка пар
                    ключ-значение (O(<i>n</i>));
                </li><li><code>map_get(TreeMap, Key, Value)</code>,
                    проверяющее, что массив содержит заданную
                    пару ключ-значение (O(log <i>n</i>)).
                </li></ul></li><li><p><b>Сложный вариант.</b>
                Дополнительно разработайте правила:
            </p><ul><li><code>map_put(TreeMap, Key, Value, Result)</code>;
                    добавляющее пару ключ-значение в массив,
                    или заменяющее текущее значение для ключа
                    (O(log <i>n</i>));
                </li><li><code>map_remove(TreeMap, Key, Result)</code>
                    удаляющее отображение для ключа
                    (O(log <i>n</i>));
                </li><li><code>map_build(ListMap, TreeMap)</code>,
                    строящее дерево из <b>не</b>упорядоченного списка пар
                    ключ-значение
                    (O(<i>n</i> log <i>n</i>)).
                </li></ul></li></ol></td><td id="sidebar"><div id="sidebar-head"><form method="get" action="https://www.google.com/search"><p><input type="hidden" name="sitesearch" value="kgeorgiy.info"></p><table><tbody><tr><td style="width:100%"><input style="width:100%" type="text" name="q" maxlength="255"></td><td><button type="submit" value="Search"><img alt="Search" src="hw_files/find.png" width="16" height="16"></button></td></tr></tbody></table></form></div><div id="sidebar-body"><h3><a href="#homework-1">Домашнее задание 1. Обработка ошибок</a></h3><h3><a href="#homework-2">Домашнее задание 2. Бинарный поиск</a></h3><h3><a href="#homework-3">Домашнее задание 3. Очередь на массиве</a></h3><h3><a href="#homework-4">Домашнее задание 4. Очереди</a></h3><h3><a href="#homework-5">Домашнее задание 5. Вычисление в различных типах</a></h3><h3><a href="#homework-6">Домашнее задание 6. Функциональные выражения на JavaScript</a></h3><h3><a href="#homework-7">Домашнее задание 7. Объектные выражения на JavaScript</a></h3><h3><a href="#homework-8">Домашнее задание 8. Обработка ошибок на JavaScript</a></h3><h3><a href="#homework-9">Домашнее задание 9. Линейная алгебра на Clojure</a></h3><h3><a href="#homework-10">Домашнее задание 10. Функциональные выражения на Clojure</a></h3><h3><a href="#homework-11">Домашнее задание 11. Объектные выражения на Clojure</a></h3><h3><a href="#homework-12">Домашнее задание 12. Комбинаторные парсеры</a></h3><h3><a href="#homework-13">Домашнее задание 13. Простые числа на Prolog</a></h3><h3><a href="#homework-14">Домашнее задание 14. Деревья поиска на Prolog</a></h3></div><div id="sidebar-foot"><a href="https://validator.w3.org/check?uri=referer"><img src="hw_files/valid-html401.png" alt="Valid HTML 4.01 Strict" width="88" height="31"></a></div></td></tr></tbody></table><script type="text/javascript">
                (function (d, w, c) {
                    (w[c] = w[c] || []).push(function() {
                        try {
                            w.yaCounter19426939 = new Ya.Metrika({
                                id:19426939,
                                clickmap:true,
                                trackLinks:true,
                                accurateTrackBounce:true,
                                webvisor:true
                            });
                        } catch(e) { }
                    });

                    var n = d.getElementsByTagName("script")[0],
                        s = d.createElement("script"),
                        f = function () { n.parentNode.insertBefore(s, n); };
                    s.type = "text/javascript";
                    s.async = true;
                    s.src = "https://mc.yandex.ru/metrika/watch.js";

                    if (w.opera == "[object Opera]") {
                        d.addEventListener("DOMContentLoaded", f, false);
                    } else { f(); }
                })(document, window, "yandex_metrika_callbacks");
                </script><noscript><div><img src="https://mc.yandex.ru/watch/19426939" style="position:absolute; left:-9999px;" alt=""></div></noscript></body></html>